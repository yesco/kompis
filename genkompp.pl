open(IN, "kom.ddl");

my $name, $no, $typ, $def, $ret;

print "// File generated by \"perl genkompp.pl\"
#include <stdio.h>
#include <stdlib.h>

int pIndent = 0;

int pNL() {
    printf(\"\\n\");
    for(int i = 0; i < pIndent; i++) {
      printf(\"  \");
    }
    return 1;
}

int pOUT(char* s) {
    printf(\"%s\", s);
    return 1;
}

int pBEGIN(char* name, char* typ) {
    pOUT(name);
    pOUT(\" : \");
    pOUT(typ);
    pIndent++;
    pNL();
    return 1;
}

int pEND(char* name) {
    //pOUT(name);
    pIndent--;
    return 1;
}

int pERROR(char* name) {
    printf(\"\\n%%Error parsing field %s\", name);
    pIndent--;
    pNL();
    return 0;
}

int pTOOBIG(char* name, long v) {
    pOUT(\"Value too big for \");
    pOUT(name);
    pOUT(\" == \");
    printf(\"%ld\", v);
    return pERROR(name);
}

// parse basic data types

char* pBuf;

int pEOF() {
    if (!pBuf || !*pBuf) return 0;
    return 1;
}

int pCHAR(char* name, char expect) {
    if (pEOF()) return (pERROR(name), 0);
    int c = *pBuf;
    if (!c) return (pERROR(name), 0);
    if (expect) {
      if (c == expect) return c;
      return 0;
    } else {
      return c;
    }
}

int pSTEP() {
    if (pEOF()) return 0;
    pBuf++;
    return *pBuf;
}

long parseLong(char* name, char* typ) {
    char* end = NULL;
    long v = strtol(pBuf, &end, 10);
    if (!end) {
      pERROR(name);
      return 0;
    }
    pBuf = end;

    // TODO: what to do at error?
    pBEGIN(name, typ);
    printf(\"%ld\", v);
    pEND(name);
    return v;
}

int pBIT(char* name, long bitv) {
    if (bitv) {
      pBEGIN(name, \"BIT\");
      pOUT(\" = 1\");
      pEND(name);
    }
    return 1;
}

int pINT8(char* name) {
    long v = parseLong(name, \"INT8\");
    if (v < 0 || v > 255)
       return pTOOBIG(name, v);
    return 1;
}

int pINT16(char* name) {
    long v = parseLong(name, \"INT16\");
    if (v < 0 || v > 65535)
       return pTOOBIG(name, v);
    return 1;
}

int pINT32(char* name) {
    long v = parseLong(name, \"INT32\");
    if (v < 0 || v >= 65536L*65536)
       return pTOOBIG(name, v);
    return 1;
}

// forward declarations
int pPers_No(char* name);
int pAux_No(char* name);
int pConf_No(char* name);
int pSession_No(char* name);
int pText_No(char* name);
int pTime(char* name);
int pAux_Item_Flags(char* name);
int pExtended_Conf_Type(char* name);
int pGarb_Nice(char* name);
int pLocal_Text_No(char* name);
int pSession_Flags(char* name);
int pENUMERATION_OF(char* name);
int pSELECTION(char* name);
int pMembership_Type(char* name);
int pPriv_Bits(char* name);
int pPersonal_Flags(char* name);
int pBOOL(char* name);
int pRead_Range(char* name);

// sparse?

/* maybe remove as is generated later?
int pPers_No(char* name) {
    long v = pINT32(name, \"Pers_No\");
    if (v < 0)
       return pTOOBIG(name, v);
    return v;
}

int pAux_No(char* name) {
    long v = pINT32(name, \"Aux_No\");
    if (v < 0)
       return pTOOBIG(name, v);
    return v;
}

int pConf_No(char* name) {
    long v = pINT16(name, \"Conf_No\");
    if (v < 0)
       return pTOOBIG(name, v);
    return v;
}

int pSession_No(char* name) {
    long v = pINT32(name, \"Session_No\");
    if (v < 0)
       return pTOOBIG(name, v);
    return v;
}

int pText_No(char* name) {
    Long v = pINT32(name, \"Text_No\");
    if (v < 0)
       return pTOOBIG(name, v);
    return v;
}

*/

int pFLOAT(char* name) {
    pERROR(name);
    return 0;
}

int pHOLLERITH(char* name) {
    pERROR(name);
    return 0;
}

typedef int(*pFuncType)(char*);

int pARRAY(pFuncType fun, char* name) {
    long n = parseLong(name, \"ArrayLength\");
    for(long i=0; i<n; i++) {
       if (!fun(name))
         return pERROR(\"ARRAY\");
    }
    return 1;
}

int pRESPONSE(char* name) {
    if (pCHAR(name, '%')) {
       // loop till fail or newline
       while(!pCHAR(name, '\\n') && pSTEP());

       return 0;
    } else if (pCHAR(name, '=')) {
      long no = parseLong(name, \"ReqNo\");
      return 1;
    } else {
      return pERROR(name);
    }
}

////////////////////
// Below: generated parsers for various types
";

my $name, $req;

while(<IN>) {
    print "// $.: $_";
    next if /^\s*$/;
    chop();
    if (/^---TYPE (\S+)/) {
	$name = $1;
    }
    if (/^---REQ (\d+) (\S+)/) {
	$req = 0 + $1;
	$name = "Q_$2";
    }
    if ($name) {
	$name =~ s/\-/_/g;
	my $typ = <IN>;
	chop($typ);
	my $def = "";
	print "int p$name(char* name) {\n";
	print "  // $typ\n";
	if ($typ eq ":BITSTRING") {
	    print "  long v = parseLong(\"name\", NULL);\n";
	}
	print "  return pBEGIN(name, \"$name\") &&\n";
	if ($typ eq ":LIST") {
	    my $maybealias = 2;
	    while (<IN>) {
		$maybealias--;
		chop();
		#print ">$_<";
		last if /^\s*$/;
		if (/->/) {
		    print "    pRESPONSE(name) &&\n";
		} elsif (/^(\S+)\s+:\s+(.+)\s*$/) {
		    my $field = $1;
		    my $t = $2;
		    $field =~ s/\-/_/g;
    		    $t =~ s/\-/_/g;
		    $t =~ s/ //g;
		
		    # sameXXXcode
		    if ($t =~ s/^ARRAY//) {
			print "    pARRAY(&p$t, \"$field\") &&\n";
		    } elsif ($t) {
			print "    p$t(\"$field\") &&\n";
		    } elsif ($maybealias) {
			print "    p$field(name) &&\n";
		    }
			
		} elsif (/^ARRAY (\S+)\s*$/) {
		    # there should only be one? type aliases?
		    my $field = $1;
		    $field =~ s/\-/_/g;
		    $field =~ s/ //g;

		    # sameXXXcode
		    if ($t =~ s/^ARRAY//) {
			print "    pARRAY(&p$t, \"$field\") &&\n";
		    } elsif ($t) {
			print "    p$t(\"$field\") &&\n";
		    } elsif ($maybealias) {
			print "    p$field(name) &&\n";
		    }
			
		} else {
		    print STDERR "\n%% Error in $name: $_\n";
		    print "\n//%% Error in $name: $_\n";
		}
	    }
	} elsif ($typ eq ":BITSTRING") {
	    my $bitv = 1;
	    while (<IN>) {
		chop();
		last if /^\s*$/;
		print "    pBIT(\"$_\", $bitv && v) &&\n";
		$bitv *= 2;
	    }
	    printf "  parseLong(\"$name\", \"BITS\") &&\n";
	} else {
	    print "%%Unknown type: $typ\n";
	}
	
	print "  pEND(name)\n";
	print "  || pERROR(name);\n";
	print "}\n\n";
	    
	$name = undef;
	$req = undef;
	next;
    }

    print "%% Error: $_\n";
}

